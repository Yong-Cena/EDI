package Lists;import ADTsException.*;import java.util.*;/** * LnkList represents a linked implementation of a list. */public abstract class LnkList<T> implements ListADT<T>, Iterable<T>{    protected int count;    protected LNode<T> head, tail;	protected int modCount;        /**     * Creates an empty list.     */    public LnkList()    {        count = 0;        head = tail = null;            modCount = 0;	}       /**     * Removes the first element in this list and returns a reference     * to it. Throws an EmptyCollectionException if the list is empty.     *     * @return a reference to the first element of this list     * @throws EmptyCollectionException if the list is empty     */    public T removeFirst() throws ADTsException    {        if (isEmpty())            throw new ADTsException("LinkedList");              LNode<T> result = head;         head = head.getNext();        if (head == null)            tail = null;        count--;		modCount++;              return result.getElement();    }       /**     * Removes the last element in this list and returns a reference     * to it. Throws an EmptyCollectionException if the list is empty.     *     * @return the last element in this list     * @throws EmptyCollectionException if the list is empty         */    public T removeLast() throws ADTsException    {        if (isEmpty())            throw new ADTsException("LinkedList");        LNode<T> previous = null;        LNode<T> current = head;        while (current.getNext() != null)        {            previous = current;             current = current.getNext();        }              LNode<T> result = tail;         tail = previous;        if (tail == null)  // only one element in list            head = null;        else            tail.setNext(null);        count--;		modCount++;              return result.getElement();    }       /**     * Removes the first instance of the specified element from this     * list and returns a reference to it. Throws an EmptyCollectionException      * if the list is empty. Throws a ElementNotFoundException if the      * specified element is not found in the list.     *     * @param  targetElement the element to be removed from the list     * @return a reference to the removed element     * @throws EmptyCollectionException if the list is empty	 * @throws ElementNotFoundException if the target element is not found     */    public T remove(T targetElement) throws ADTsException,          ADTsException     {        if (isEmpty())            throw new ADTsException("LinkedList");              boolean found = false;        LNode<T> previous = null;        LNode<T> current = head;              while (current != null && !found)            if (targetElement.equals(current.getElement()))                found = true;            else            {                previous = current;                current = current.getNext();            }                    if (!found)            throw new ADTsException("LinkedList");              if (size() == 1)  // only one element in the list            head = tail = null;        else if (current.equals(head))  // target is at the head             head = current.getNext();        else if (current.equals(tail))  // target is at the tail        {            tail = previous;            tail.setNext(null);        }        else  // target is in the middle            previous.setNext(current.getNext());              count--;		modCount++;              return current.getElement();    }       /**     * Returns the first element in this list without removing it.      *     * @return the first element in this list	 * @throws EmptyCollectionException if the list is empty     */    public T first() throws ADTsException    {		if (isEmpty())            throw new ADTsException("LnkList");		        return head.getElement();    }	    /**     * Returns the last element in this list without removing it.      *     * @return the last element in this list  	 * @throws EmptyCollectionException if the list is empty     */    public T last() throws ADTsException    {        if (isEmpty())            throw new ADTsException("LnkList");		        return tail.getElement();    }	    /**     * Returns true if the specified element is found in this list and      * false otherwise. Throws an EmptyCollectionException if the list 	 * is empty.     *     * @param  targetElement the element that is sought in the list     * @return true if the element is found in this list     * @throws EmptyCollectionException if the list is empty     */    public boolean contains(T targetElement) throws          ADTsException     {        if (isEmpty())            throw new ADTsException("LnkList");        boolean found = false;        LNode<T> current = head;        while (current != null && !found)             if (targetElement.equals(current.getElement()))                found = true;            else                current = current.getNext();              return found;    }        /**     * Problema 48, metodo Iterativo     * Encuentra en la lista la primera ocurrencia del elemento.     * Regresa su posición o cero, si no está en la lista.     */    public int find(T element) {        T aux;        int pos, result;        boolean flag;        Iterator<T> it= this.iterator();        flag= false;        pos= 0;        while(it.hasNext() && !flag ) {            //Busca el elemento en la lista.            aux= it.next();            flag= aux.equals(element);            pos++;        }        result = (flag) ? pos : 0;         return result;    }        /**     * Problema 48, metodos Indirecto Recursivo     */    public int findRv(T element) {        T aux;        int pos, result;        boolean flag;        Iterator<T> it= this.iterator();        flag= false;        pos= 1;        result = findRv(it, pos, element);         return result;    }    private int findRv(Iterator<T> it, int pos, T element) {        T auxt;        if( !it.hasNext() ) {            // Caso Base            pos = 0;        } else {            //Busca el elemento en la lista.            auxt= it.next();            if( !auxt.equals(element) ) {                pos = findRv(it, pos+1, element);            }        }        return pos;    }        /**     * Returns true if this list is empty and false otherwise.     *     * @return true if the list is empty, false otherwise     */    public boolean isEmpty()    {        return (count == 0);    }    /**     * Returns the number of elements in this list.     *     * @return the number of elements in the list     */    public int size()    {        return count;    }    /**     * Problema 48. Iterative case.     * @return a string representation of the list         */    public String toString() {        LNode<T> current = head;        String result = "  {LnkList";        if( this.isEmpty() ) {            result = result + ", is EMPTY";        }         while (current != null)        {            result = result + ", " + current.getElement();            current = current.getNext();        }                result = result + "}";        return result;    }    /**     * Problema 48. Recursive case.     * @return a string representation of the list         */    public String toStringRv() {        LNode<T> current = head;        String cadei = "  {LnkList-Rv";                if( this.isEmpty() ) {            cadei = cadei + ", is EMPTY";        } else {            cadei = cadei + toStringRv(current);        }                 cadei = cadei + "}";            return cadei;    }        private String toStringRv(LNode<T> actual) {        String cader = "";                if( actual == null ) {            // Caso Base            cader = "";        } else {            cader = ", " + actual.getElement() +                    toStringRv(actual.getNext());                    }        return cader;    }        /**     * Problema 50. Iterative case.     * @return a boolean, with true means both are equal         */    public boolean equals( Object otra ) throws ADTsException {        if( otra == null || !(otra instanceof LnkList) ) {            throw new ADTsException("LnkList.equals: null or wrong instance");        }        boolean eqls;         Iterator<T> ithis, itol;        LnkList otralis = (LnkList) otra;        eqls = this.size() == otralis.size();        if ( eqls ) {            ithis= this.iterator();            itol= otralis.iterator();             while( ithis.hasNext() && eqls ) {                eqls = ithis.next().equals( itol.next() );            }        }                return eqls;    }        /**     * Problema 50. Recursive case. Indirect Recursive.     * @return a boolean, with true means both are equal         */    public boolean equalsRv( Object otra ) throws ADTsException {        if( otra == null || !(otra instanceof LnkList) ) {            throw new ADTsException("LnkList.equals: null or wrong instance");        }        boolean eqls;         Iterator<T> ithis, itol;        LnkList otralis = (LnkList) otra;        eqls = this.size() == otralis.size();        if ( eqls ) {            ithis= this.iterator();            itol= otralis.iterator();             eqls = equalsRv(ithis, itol, eqls);        }        return eqls;    }    private boolean equalsRv( Iterator<T> ith, Iterator<T> ito, boolean igl ) {                    if( ith.hasNext() && igl ) {                igl = ith.next().equals( ito.next() );                igl = equalsRv(ith, ito, igl);            }                return igl;    }            /**     * Returns an iterator for the elements in this list.      *     * @return an iterator over the elements of the list     */    public Iterator<T> iterator()    {        return new LinkedListIterator();    }        /** Clears this list (this list becomes empty).     */    public void clear() {        count = 0;        head = tail = null;            modCount = 0;            }        // ==========================        /**     * LinkedIterator represents an iterator for a linked list of linear nodes.     */    private class LinkedListIterator implements Iterator<T>    {        private int iteratorModCount;  // the number of elements in the collection        private LNode<T> current;  // the current position        /**         * Sets up this iterator using the specified items.         *         * @param collection  the collection the iterator will move over         * @param size        the integer size of the collection         */        public LinkedListIterator()        {                current = head;                iteratorModCount = modCount;        }        /**         * Returns true if this iterator has at least one more element         * to deliver in the iteration.         *         * @return  true if this iterator has at least one more element to deliver         *          in the iteration         * @throws  ConcurrentModificationException if the collection has changed         *          while the iterator is in use         */        public boolean hasNext() throws ConcurrentModificationException        {                if (iteratorModCount != modCount)                         throw new ConcurrentModificationException();                return (current != null);        }        /**         * Returns the next element in the iteration. If there are no         * more elements in this iteration, a NoSuchElementException is         * thrown.         *         * @return the next element in the iteration         * @throws NoSuchElementException if the iterator is empty         */        public T next() throws ConcurrentModificationException        {                if (!hasNext())                        throw new NoSuchElementException();                T result = current.getElement();                current = current.getNext();                return result;        }        /**         * The remove operation is not supported.         *          * @throws UnsupportedOperationException if the remove operation is called         */        public void remove() throws UnsupportedOperationException        {                throw new UnsupportedOperationException();        }    } // END private class LinkedListIterator implements Iterator<T>	}  // END public abstract class LnkList<T> implements ListADT<T>, Iterable<T>